package ledgercore

// Code generated by github.com/algorand/msgp DO NOT EDIT.

import (
	"sort"
	
	"github.com/Orca18/novarand/data/basics"
	"github.com/algorand/msgp/msgp"
)

// The following msgp objects are implemented in this file:
// AccountTotals
//       |-----> (*) MarshalMsg
//       |-----> (*) CanMarshalMsg
//       |-----> (*) UnmarshalMsg
//       |-----> (*) CanUnmarshalMsg
//       |-----> (*) Msgsize
//       |-----> (*) MsgIsZero
//
// AlgoCount
//     |-----> (*) MarshalMsg
//     |-----> (*) CanMarshalMsg
//     |-----> (*) UnmarshalMsg
//     |-----> (*) CanUnmarshalMsg
//     |-----> (*) Msgsize
//     |-----> (*) MsgIsZero
//

// MarshalMsg implements msgp.Marshaler
func (z *AccountTotals) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(4)
	var zb0001Mask uint8 /* 5 bits */
	if ((*z).NotParticipating.Money.MsgIsZero()) && ((*z).NotParticipating.RewardUnits == 0) {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if ((*z).Offline.Money.MsgIsZero()) && ((*z).Offline.RewardUnits == 0) {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if ((*z).Online.Money.MsgIsZero()) && ((*z).Online.RewardUnits == 0) {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if (*z).RewardsLevel == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "notpart"
			o = append(o, 0xa7, 0x6e, 0x6f, 0x74, 0x70, 0x61, 0x72, 0x74)
			// omitempty: check for empty values
			zb0002Len := uint32(2)
			var zb0002Mask uint8 /* 3 bits */
			if (*z).NotParticipating.Money.MsgIsZero() {
				zb0002Len--
				zb0002Mask |= 0x2
			}
			if (*z).NotParticipating.RewardUnits == 0 {
				zb0002Len--
				zb0002Mask |= 0x4
			}
			// variable map header, size zb0002Len
			o = append(o, 0x80|uint8(zb0002Len))
			if (zb0002Mask & 0x2) == 0 { // if not empty
				// string "mon"
				o = append(o, 0xa3, 0x6d, 0x6f, 0x6e)
				o = (*z).NotParticipating.Money.MarshalMsg(o)
			}
			if (zb0002Mask & 0x4) == 0 { // if not empty
				// string "rwd"
				o = append(o, 0xa3, 0x72, 0x77, 0x64)
				o = msgp.AppendUint64(o, (*z).NotParticipating.RewardUnits)
			}
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "offline"
			o = append(o, 0xa7, 0x6f, 0x66, 0x66, 0x6c, 0x69, 0x6e, 0x65)
			// omitempty: check for empty values
			zb0003Len := uint32(2)
			var zb0003Mask uint8 /* 3 bits */
			if (*z).Offline.Money.MsgIsZero() {
				zb0003Len--
				zb0003Mask |= 0x2
			}
			if (*z).Offline.RewardUnits == 0 {
				zb0003Len--
				zb0003Mask |= 0x4
			}
			// variable map header, size zb0003Len
			o = append(o, 0x80|uint8(zb0003Len))
			if (zb0003Mask & 0x2) == 0 { // if not empty
				// string "mon"
				o = append(o, 0xa3, 0x6d, 0x6f, 0x6e)
				o = (*z).Offline.Money.MarshalMsg(o)
			}
			if (zb0003Mask & 0x4) == 0 { // if not empty
				// string "rwd"
				o = append(o, 0xa3, 0x72, 0x77, 0x64)
				o = msgp.AppendUint64(o, (*z).Offline.RewardUnits)
			}
		}
		if (zb0001Mask & 0x8) == 0 { // if not empty
			// string "online"
			o = append(o, 0xa6, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65)
			// omitempty: check for empty values
			zb0004Len := uint32(2)
			var zb0004Mask uint8 /* 3 bits */
			if (*z).Online.Money.MsgIsZero() {
				zb0004Len--
				zb0004Mask |= 0x2
			}
			if (*z).Online.RewardUnits == 0 {
				zb0004Len--
				zb0004Mask |= 0x4
			}
			// variable map header, size zb0004Len
			o = append(o, 0x80|uint8(zb0004Len))
			if (zb0004Mask & 0x2) == 0 { // if not empty
				// string "mon"
				o = append(o, 0xa3, 0x6d, 0x6f, 0x6e)
				o = (*z).Online.Money.MarshalMsg(o)
			}
			if (zb0004Mask & 0x4) == 0 { // if not empty
				// string "rwd"
				o = append(o, 0xa3, 0x72, 0x77, 0x64)
				o = msgp.AppendUint64(o, (*z).Online.RewardUnits)
			}
		}
		if (zb0001Mask & 0x10) == 0 { // if not empty
			// string "rwdlvl"
			o = append(o, 0xa6, 0x72, 0x77, 0x64, 0x6c, 0x76, 0x6c)
			o = msgp.AppendUint64(o, (*z).RewardsLevel)
		}
	}
	return
}

func (_ *AccountTotals) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*AccountTotals)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AccountTotals) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			var zb0003 int
			var zb0004 bool
			zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0003, zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Online")
					return
				}
				if zb0003 > 0 {
					zb0003--
					bts, err = (*z).Online.Money.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Online", "struct-from-array", "Money")
						return
					}
				}
				if zb0003 > 0 {
					zb0003--
					(*z).Online.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Online", "struct-from-array", "RewardUnits")
						return
					}
				}
				if zb0003 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0003)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Online", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Online")
					return
				}
				if zb0004 {
					(*z).Online = AlgoCount{}
				}
				for zb0003 > 0 {
					zb0003--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Online")
						return
					}
					switch string(field) {
					case "mon":
						bts, err = (*z).Online.Money.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Online", "Money")
							return
						}
					case "rwd":
						(*z).Online.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Online", "RewardUnits")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Online")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0005 int
			var zb0006 bool
			zb0005, zb0006, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0005, zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Offline")
					return
				}
				if zb0005 > 0 {
					zb0005--
					bts, err = (*z).Offline.Money.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Offline", "struct-from-array", "Money")
						return
					}
				}
				if zb0005 > 0 {
					zb0005--
					(*z).Offline.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Offline", "struct-from-array", "RewardUnits")
						return
					}
				}
				if zb0005 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0005)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Offline", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "Offline")
					return
				}
				if zb0006 {
					(*z).Offline = AlgoCount{}
				}
				for zb0005 > 0 {
					zb0005--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "Offline")
						return
					}
					switch string(field) {
					case "mon":
						bts, err = (*z).Offline.Money.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Offline", "Money")
							return
						}
					case "rwd":
						(*z).Offline.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Offline", "RewardUnits")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "Offline")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			var zb0007 int
			var zb0008 bool
			zb0007, zb0008, bts, err = msgp.ReadMapHeaderBytes(bts)
			if _, ok := err.(msgp.TypeError); ok {
				zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "NotParticipating")
					return
				}
				if zb0007 > 0 {
					zb0007--
					bts, err = (*z).NotParticipating.Money.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "NotParticipating", "struct-from-array", "Money")
						return
					}
				}
				if zb0007 > 0 {
					zb0007--
					(*z).NotParticipating.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "NotParticipating", "struct-from-array", "RewardUnits")
						return
					}
				}
				if zb0007 > 0 {
					err = msgp.ErrTooManyArrayFields(zb0007)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "NotParticipating", "struct-from-array")
						return
					}
				}
			} else {
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "NotParticipating")
					return
				}
				if zb0008 {
					(*z).NotParticipating = AlgoCount{}
				}
				for zb0007 > 0 {
					zb0007--
					field, bts, err = msgp.ReadMapKeyZC(bts)
					if err != nil {
						err = msgp.WrapError(err, "struct-from-array", "NotParticipating")
						return
					}
					switch string(field) {
					case "mon":
						bts, err = (*z).NotParticipating.Money.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "NotParticipating", "Money")
							return
						}
					case "rwd":
						(*z).NotParticipating.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "NotParticipating", "RewardUnits")
							return
						}
					default:
						err = msgp.ErrNoField(string(field))
						if err != nil {
							err = msgp.WrapError(err, "struct-from-array", "NotParticipating")
							return
						}
					}
				}
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardsLevel")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = AccountTotals{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "online":
				var zb0009 int
				var zb0010 bool
				zb0009, zb0010, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0009, zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Online")
						return
					}
					if zb0009 > 0 {
						zb0009--
						bts, err = (*z).Online.Money.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Online", "struct-from-array", "Money")
							return
						}
					}
					if zb0009 > 0 {
						zb0009--
						(*z).Online.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Online", "struct-from-array", "RewardUnits")
							return
						}
					}
					if zb0009 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0009)
						if err != nil {
							err = msgp.WrapError(err, "Online", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "Online")
						return
					}
					if zb0010 {
						(*z).Online = AlgoCount{}
					}
					for zb0009 > 0 {
						zb0009--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Online")
							return
						}
						switch string(field) {
						case "mon":
							bts, err = (*z).Online.Money.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Online", "Money")
								return
							}
						case "rwd":
							(*z).Online.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Online", "RewardUnits")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "Online")
								return
							}
						}
					}
				}
			case "offline":
				var zb0011 int
				var zb0012 bool
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0011, zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "Offline")
						return
					}
					if zb0011 > 0 {
						zb0011--
						bts, err = (*z).Offline.Money.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "Offline", "struct-from-array", "Money")
							return
						}
					}
					if zb0011 > 0 {
						zb0011--
						(*z).Offline.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "Offline", "struct-from-array", "RewardUnits")
							return
						}
					}
					if zb0011 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0011)
						if err != nil {
							err = msgp.WrapError(err, "Offline", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "Offline")
						return
					}
					if zb0012 {
						(*z).Offline = AlgoCount{}
					}
					for zb0011 > 0 {
						zb0011--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "Offline")
							return
						}
						switch string(field) {
						case "mon":
							bts, err = (*z).Offline.Money.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "Offline", "Money")
								return
							}
						case "rwd":
							(*z).Offline.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "Offline", "RewardUnits")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "Offline")
								return
							}
						}
					}
				}
			case "notpart":
				var zb0013 int
				var zb0014 bool
				zb0013, zb0014, bts, err = msgp.ReadMapHeaderBytes(bts)
				if _, ok := err.(msgp.TypeError); ok {
					zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "NotParticipating")
						return
					}
					if zb0013 > 0 {
						zb0013--
						bts, err = (*z).NotParticipating.Money.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "NotParticipating", "struct-from-array", "Money")
							return
						}
					}
					if zb0013 > 0 {
						zb0013--
						(*z).NotParticipating.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
						if err != nil {
							err = msgp.WrapError(err, "NotParticipating", "struct-from-array", "RewardUnits")
							return
						}
					}
					if zb0013 > 0 {
						err = msgp.ErrTooManyArrayFields(zb0013)
						if err != nil {
							err = msgp.WrapError(err, "NotParticipating", "struct-from-array")
							return
						}
					}
				} else {
					if err != nil {
						err = msgp.WrapError(err, "NotParticipating")
						return
					}
					if zb0014 {
						(*z).NotParticipating = AlgoCount{}
					}
					for zb0013 > 0 {
						zb0013--
						field, bts, err = msgp.ReadMapKeyZC(bts)
						if err != nil {
							err = msgp.WrapError(err, "NotParticipating")
							return
						}
						switch string(field) {
						case "mon":
							bts, err = (*z).NotParticipating.Money.UnmarshalMsg(bts)
							if err != nil {
								err = msgp.WrapError(err, "NotParticipating", "Money")
								return
							}
						case "rwd":
							(*z).NotParticipating.RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
							if err != nil {
								err = msgp.WrapError(err, "NotParticipating", "RewardUnits")
								return
							}
						default:
							err = msgp.ErrNoField(string(field))
							if err != nil {
								err = msgp.WrapError(err, "NotParticipating")
								return
							}
						}
					}
				}
			case "rwdlvl":
				(*z).RewardsLevel, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardsLevel")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *AccountTotals) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*AccountTotals)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AccountTotals) Msgsize() (s int) {
	s = 1 + 7 + 1 + 4 + (*z).Online.Money.Msgsize() + 4 + msgp.Uint64Size + 8 + 1 + 4 + (*z).Offline.Money.Msgsize() + 4 + msgp.Uint64Size + 8 + 1 + 4 + (*z).NotParticipating.Money.Msgsize() + 4 + msgp.Uint64Size + 7 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *AccountTotals) MsgIsZero() bool {
	return (((*z).Online.Money.MsgIsZero()) && ((*z).Online.RewardUnits == 0)) && (((*z).Offline.Money.MsgIsZero()) && ((*z).Offline.RewardUnits == 0)) && (((*z).NotParticipating.Money.MsgIsZero()) && ((*z).NotParticipating.RewardUnits == 0)) && ((*z).RewardsLevel == 0)
}

// MarshalMsg implements msgp.Marshaler
func (z *AlgoCount) MarshalMsg(b []byte) (o []byte) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 3 bits */
	if (*z).Money.MsgIsZero() {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if (*z).RewardUnits == 0 {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len != 0 {
		if (zb0001Mask & 0x2) == 0 { // if not empty
			// string "mon"
			o = append(o, 0xa3, 0x6d, 0x6f, 0x6e)
			o = (*z).Money.MarshalMsg(o)
		}
		if (zb0001Mask & 0x4) == 0 { // if not empty
			// string "rwd"
			o = append(o, 0xa3, 0x72, 0x77, 0x64)
			o = msgp.AppendUint64(o, (*z).RewardUnits)
		}
	}
	return
}

func (_ *AlgoCount) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*AlgoCount)
	return ok
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AlgoCount) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 int
	var zb0002 bool
	zb0001, zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
	if _, ok := err.(msgp.TypeError); ok {
		zb0001, zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0001 > 0 {
			zb0001--
			bts, err = (*z).Money.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "Money")
				return
			}
		}
		if zb0001 > 0 {
			zb0001--
			(*z).RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "RewardUnits")
				return
			}
		}
		if zb0001 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0001)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else {
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		if zb0002 {
			(*z) = AlgoCount{}
		}
		for zb0001 > 0 {
			zb0001--
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			switch string(field) {
			case "mon":
				bts, err = (*z).Money.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Money")
					return
				}
			case "rwd":
				(*z).RewardUnits, bts, err = msgp.ReadUint64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RewardUnits")
					return
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

func (_ *AlgoCount) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*AlgoCount)
	return ok
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AlgoCount) Msgsize() (s int) {
	s = 1 + 4 + (*z).Money.Msgsize() + 4 + msgp.Uint64Size
	return
}

// MsgIsZero returns whether this is a zero value
func (z *AlgoCount) MsgIsZero() bool {
	return ((*z).Money.MsgIsZero()) && ((*z).RewardUnits == 0)
}

// (추가)MarshalMsg implements msgp.Marshaler
func (z *AccountDeltas) MarshalMsg(b []byte) (o []byte) {
	// 마샬링한 결과를 저장할 byte 배열(o)의 크기를 정하는 메소드.
	o = msgp.Require(b, z.Msgsize())

	// omitempty: check for empty values
	// 구조체가 가지고 있는 속성의 갯수만큼 길이를 지정한다.
	// 속성의 값이 없다면 길이도 1씩 줄여준다.
	zb0003Len := uint32(2)
	// 마스크의 자료형은 속성의 갯수에 따라 달라진다.
	// 여기선 구조체 속성의 갯수가 2개라 uint8로도 커버가 가능하다.
	var zb0003Mask uint8 /* 7 bits */
	
	// 값이 없다면 길이를 1 감소
	// or연산을 해줌 00000000 | 00000010 => 00000010
	if len((*z).accts) == 0 {
		zb0003Len--
		zb0003Mask |= 0x2
	}
	// 값이 없다면 길이를 1 감소
	// or연산을 해줌 00000000 | 00000100 => 00000100
	if len((*z).acctsCache) == 0 {
		zb0003Len--
		zb0003Mask |= 0x4
	}

	// variable map header, size zb0003Len
	// 왜 맵인진 모르겠지만.. 10000000 | 0000xxxx(15까지 가능! 즉, 구조체안에 포함된 속성은 15개까지만 저장가능함!)
	o = append(o, 0x80|uint8(zb0003Len))
	// 길이가 0이 라니라면 마샬링 작업을 수행한다.
	// 당연히!! 0이면 마샬링할 필요가 없다. 데이터가 없는데 왜 마샬링을 하냐!
	if zb0003Len != 0 {
		// 위에서 체크 시 첫번째 속성의 길이가 0이 아니라면 xxxxxx00일 것이다.
		// 따라서 데이터가 있다면 xxxxxx00 & 00000010연산을 하므로 0이 나와야 한다.
		// 만약 데이터가 없다면 xxxxxx10 & 00000010 이므로 0이 아니다!
		if (zb0003Mask & 0x2) == 0 { // if not empty
			// string "accts"
			// 배열에 문자열을 넣을 때 첫번째 바이트는 문자열의 갯수(0xa5 == 5)
			// 나머지 바이트에는 각 문자열의 16진수형태 값을 넣어준다.
			o = append(o, 0xa5, 0x61, 0x63, 0x63, 0x74, 0x73)
			// 실제 값을 넣어준다. nil이라면 nil을 추가한다.
			if (*z).accts == nil {
				o = msgp.AppendNil(o)
			} else {
				// nil이 아니라면 헤더에 배열의 사이즈를 넣어준다.
				o = msgp.AppendArrayHeader(o, uint32(len((*z).accts)))
			}
			// 배열의 길이만큼 반복한다. 만약 nil이라면 반복하지 않는다.
			for zb0002 := range (*z).accts {
				// 배열의 각 값에 대해 각각 마샬링 작업을 한다.
				o = (*z).accts[zb0002].MarshalMsg(o)
			}
		}
		if (zb0003Mask & 0x4) == 0 { // if not empty
			// string "cache"
			o = append(o, 0xa5, 0x63, 0x61, 0x63, 0x68, 0x65)
			if (*z).acctsCache == nil {
				o = msgp.AppendNil(o)
			} else {
				// 해당 맵이 nil이 아니라면 맵의 크기를 o에 저장해준다.
				o = msgp.AppendMapHeader(o, uint32(len((*z).acctsCache)))
			}
			// 해당 맵이 가지고 있는 key들을 저장할 슬라이스를 만든다.
			zb0001_keys := make([]basics.Address, 0, len((*z).acctsCache))
			// 맵의 길이만큼 반복한다.
			for zb0001 := range (*z).acctsCache {
				// for range를 map에서 사용하면 key값만 순회한다.
				// key값들을 슬라이스에 추가!
				zb0001_keys = append(zb0001_keys, zb0001)
			}
			// sort한다
			sort.Sort(basics.SortAddress(zb0001_keys))
			
			// 키의 길이만큼 반복
			for _, zb0001 := range zb0001_keys {
				// 해당 맵의 해당 키의 int값을 사져론다.
				zb0002 := (*z).acctsCache[zb0001]
				
				// 키값을 마샬링한다.
				o = zb0001.MarshalMsg(o)
				// 키에 해당하는 값을 마샬링한다(원래는 int로 저장돼있는데 Append-에 없어서 int64로 캐스팅 함! 
				// unmarshal 시 다시 int로 캐스팅해줘야 한다면 해주기)
				// int는 64bit 시스템에선 int64와 동일해서 상관없을 것 같긴한데.. 흠 한번 보기!
				o = msgp.AppendInt64(o, int64(zb0002))
			}
		}
	}
	return
}

// (추가)
func (_ *AccountDeltas) CanMarshalMsg(z interface{}) bool {
	_, ok := (z).(*AccountDeltas)
	return ok
}

// (추가)UnmarshalMsg implements msgp.Unmarshaler
func (z *AccountDeltas) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0003 int
	var zb0004 bool
	// 맵의 사이즈, nil여부, 맵사이즈 바이트 제외한 나머지 바이트 , 에러여부
	zb0003, zb0004, bts, err = msgp.ReadMapHeaderBytes(bts)
	// 타입에러가 발생했다면
	if _, ok := err.(msgp.TypeError); ok {
		// 전체길이가 0보다 크다면
		if zb0003 > 0 { // 2
			// 전체길이 --
			zb0003-- // 1
			var zb0007 int
			var zb0008 bool
			// 배열의 사이즈, nil여부, 배열사이즈 바이트 제외한 나머지 바이트 , 에러여부
			zb0007, zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "accts")
				return
			}
			if zb0008 {
				(*z).accts = nil
			} else if (*z).accts != nil && cap((*z).accts) >= zb0007 {
				(*z).accts = ((*z).accts)[:zb0007]
			} else {
				(*z).accts = make([]basics.BalanceRecord, zb0007)
			}
			for zb0001 := range (*z).accts {
				bts, err = (*z).accts[zb0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "accts", zb0001)
					return
				}
			}
		}
		if zb0003 > 0 { // 1
			zb0003-- // 0
			var zb0009 int
			var zb00010 bool
			// 맵의 사이즈, nil여부, 맵사이즈 바이트 제외한 나머지 바이트 , 에러여부
			zb0009, zb00010, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array", "cache")
				return
			}

			if zb00010 {
				(*z).acctsCache = nil
			} else if (*z).acctsCache == nil {
				(*z).acctsCache = make(map[basics.Address]int, zb0009)
			}
			for zb0009 > 0 { // 맵의 갯수만큼 반복
				var zb0001 basics.Address //key
				var zb0002 int64 //value
				zb0009-- // 갯수 -1
				bts, err = zb0001.UnmarshalMsg(bts) // key언마샬!
				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "cache")
					return
				}
				zb0002, bts, err = msgp.ReadInt64Bytes(bts)

				if err != nil {
					err = msgp.WrapError(err, "struct-from-array", "cache", zb0001)
					return
				}
				(*z).acctsCache[zb0001] = int(zb0002)
			}
		}
		if zb0003 > 0 {
			err = msgp.ErrTooManyArrayFields(zb0003)
			if err != nil {
				err = msgp.WrapError(err, "struct-from-array")
				return
			}
		}
	} else { // 타입에러가 발생하지 않았다면!
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		// 에러가 발생했다면
		if zb0004 {
			// 빈 구조체 생성
			(*z) = AccountDeltas{}
		}
		// 전체 길이가 0보다 크다면
		for zb0003 > 0 {
			zb0003--
			// 필드값을 읽어온다!
			field, bts, err = msgp.ReadMapKeyZC(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
			// String값에 따라 분기한다!!
			switch string(field) {
			case "accts":
				var zb0013 int
				var zb0014 bool
				// 배열의 사이즈, nil여부, 배열사이즈 바이트 제외한 나머지 바이트 , 에러여부
				zb0013, zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "accts")
					return
				}
				/*
				크기 관련한 값 딱히 필요없어서 사용안함 나중에 필요 시 넣기!!
				if zb0013 > config.MaxVoteThreshold {
					err = msgp.ErrOverflow(uint64(zb0013), uint64(config.MaxVoteThreshold))
					err = msgp.WrapError(err, "Votes")
					return
				}*/
				// 에러 발생 시 nil
				if zb0014 {
					(*z).accts = nil
				} else if (*z).accts != nil && cap((*z).accts) >= zb0013 { //accts배열의 가용크기가 accts 배열의 크기보다 크거나 같다면
					(*z).accts = ((*z).accts)[:zb0013]
				} else {
					(*z).accts = make([]basics.BalanceRecord, zb0013)
				}
				for zb0001 := range (*z).accts {
					bts, err = (*z).accts[zb0001].UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "accts", zb0001)
						return
					}
				}
			case "cache":
				var zb0011 int
				var zb0012 bool
				// 맵의 사이즈, nil여부, 맵의 사이즈 바이트 제외한 나머지 바이트 , 에러여부
				zb0011, zb0012, bts, err = msgp.ReadMapHeaderBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "cache")
					return
				}
				/* 사이즈 임계값 필요없어서 안함 혹시 나중에 필요하면 해당 코드 넣기
				if zb0011 > protocol.NumCompactCertTypes {
					err = msgp.ErrOverflow(uint64(zb0011), uint64(protocol.NumCompactCertTypes))
					err = msgp.WrapError(err, "cache")
					return
				}
				*/
				// 에러가 있다면!
				if zb0012 {
					(*z).acctsCache = nil
				} else if (*z).acctsCache == nil {
					(*z).acctsCache = make(map[basics.Address]int, zb0011)
				}
				for zb0011 > 0 {
					var zb0001 basics.Address
					var zb0002 int64
					zb0011--
					bts, err = zb0001.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "cache")
						return
					}
					zb0002, bts, err = msgp.ReadInt64Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "cache", zb0001)
						return
					}
					(*z).acctsCache[zb0001] = int(zb0002)
				}
			default:
				err = msgp.ErrNoField(string(field))
				if err != nil {
					err = msgp.WrapError(err)
					return
				}
			}
		}
	}
	o = bts
	return
}

// (추가)
func (_ *AccountDeltas) CanUnmarshalMsg(z interface{}) bool {
	_, ok := (z).(*AccountDeltas)
	return ok
}

// (추가)Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AccountDeltas) Msgsize() (s int) {
	/* 
		1: 구조체에 들어간 속성의 갯수를 저장함(1000xxxx)
		6: 'accts'가 5바이트 + 문자열의 갯수저장에 1바이트
		ArrayHeaderSize: 해당 배열의 총 사이즈를 저장한 바이트
		(*z).accts[zb0001].Msgsize(): 배열에 저장된 각 속성값의 크기
		
		6: 'cache'가 5바이트 + 문자열의 갯수저장에 1바이트
		msgp.MapHeaderSize: 해당 맵의 총 사이즈를 저장한 바이트
		msgp.Int64Size: 해당 맵이 int를 저장하고 있으므로 맵의 사이즈만큼 int의 크기
	*/
	s = 1 + 6 + msgp.ArrayHeaderSize
	for zb0001 := range (*z).accts {
		s += (*z).accts[zb0001].Msgsize()
	}

	s += 6 + msgp.MapHeaderSize
	for i :=0; i < len((*z).acctsCache); i++ {
		s += msgp.Int64Size
	}

	return
}

// (추가)MsgIsZero returns whether this is a zero value
func (z *AccountDeltas) MsgIsZero() bool {
	return (len((*z).accts) == 0) && (len((*z).acctsCache) == 0)
}
