// Copyright (C) 2019-2022 Algorand, Inc.
// This file is part of go-algorand
//
// go-algorand is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License, or (at your option) any later version.
//
// go-algorand is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with go-algorand.  If not, see <https://www.gnu.org/licenses/>.

package data

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"sync"

	"github.com/Orca18/novarand/crypto"
	"github.com/Orca18/novarand/data/bookkeeping"
	"github.com/Orca18/novarand/data/pools"
	"github.com/Orca18/novarand/data/transactions"
	"github.com/Orca18/novarand/data/transactions/verify"
	"github.com/Orca18/novarand/logging"
	"github.com/Orca18/novarand/network"
	"github.com/Orca18/novarand/protocol"
	"github.com/Orca18/novarand/util/execpool"
	"github.com/Orca18/novarand/util/metrics"
)

// The size txBacklogSize used to determine the size of the backlog that is used to store incoming transaction messages before starting dropping them.
// It should be configured to be higher then the number of CPU cores, so that the execution pool get saturated, but not too high to avoid lockout of the
// execution pool for a long duration of time.
/*
트랜잭션 로그 사이즈
*/
const txBacklogSize = 1000

// Number of transaction messages handled
var transactionMessagesHandled = metrics.MakeCounter(metrics.TransactionMessagesHandled)

// "Number of transaction messages dropped from backlog
var transactionMessagesDroppedFromBacklog = metrics.MakeCounter(metrics.TransactionMessagesDroppedFromBacklog)

// Number of transaction messages dropped from pool
var transactionMessagesDroppedFromPool = metrics.MakeCounter(metrics.TransactionMessagesDroppedFromPool)

// The txBacklogMsg structure used to track a single incoming transaction from the gossip network,
/*
	gossip network에서 들어오는 싱글 트랜잭션을 처리하기 위한 구조체
	싱글 메시지 뿐 아니라 검증되지 않은 트랜잭션 그룹 또한 들어온다.
*/
type txBacklogMsg struct {
	// 가십네트워크에서 들어온 인커밍 메시지
	rawmsg *network.IncomingMessage // the raw message from the network
	// 서명되어있지만 검증되지 않은 트랜잭션 그룹
	unverifiedTxGroup []transactions.SignedTxn // the unverified ( and signed ) transaction group
	// 검증시 발생할 수 있는 에러
	verificationErr error // The verification error generated by the verification function, if any.
}

// TxHandler handles transaction messages
// TxHandler는 트랜잭션 메시지를 처리하는 구조체이다.
type TxHandler struct {
	txPool      *pools.TransactionPool
	ledger      *Ledger
	genesisID   string
	genesisHash crypto.Digest

	// BacklogPool은 모든 ExecutionPool 기능과 pending task를 테스트하는 몇 가지 기능을 추가로 지원합니다
	txVerificationPool execpool.BacklogPool

	// 가십네트워크에서 들어온 싱글 트랜잭션의 추적로그를 저장하는 큐
	backlogQueue chan *txBacklogMsg

	//
	postVerificationQueue chan *txBacklogMsg

	/*
		WaitGroup은 고루틴 컬렉션이 종료될 때까지 기다린다.
		메인 고루틴이 기다릴 고루틴들을 등록하기 위해 Add를 호출한다.
		그러면 각 고루틴이 실행되고 종료 시 Done을 호출한다. 동시에(뭐와 동시지??)
		Wait은 모든 고루틴이 종료될 때까지 블록할 수 있다.
		WaitGroup은 처음 사용 후에 복사되서는 안된다.
		=> 백로그를 저장할 고루틴들이 모두 종료될 때까지 기다리는 객체
	*/
	backlogWg sync.WaitGroup

	// 가십네트워크에서 사용하는 노드 객체
	// 얘가 트랜잭션을 받아온다.
	net network.GossipNode

	// 작업에 대한 정보를 알려주는 객체(종료됐는지, 에러가 났는지 등)
	ctx context.Context
	// CancelFunc는 작업을 중단하도록 지시하는 객체
	ctxCancel context.CancelFunc
}

// MakeTxHandler makes a new handler for transaction messages
// MakeTxHandler는 트랜잭션 메시지에 대한 새로운 핸들러를 만듭니다.
func MakeTxHandler(txPool *pools.TransactionPool, ledger *Ledger, net network.GossipNode, genesisID string, genesisHash crypto.Digest, executionPool execpool.BacklogPool) *TxHandler {

	if txPool == nil {
		logging.Base().Fatal("MakeTxHandler: txPool is nil on initialization")
		return nil
	}

	if ledger == nil {
		logging.Base().Fatal("MakeTxHandler: ledger is nil on initialization")
		return nil
	}

	handler := &TxHandler{
		txPool:                txPool,
		genesisID:             genesisID,
		genesisHash:           genesisHash,
		ledger:                ledger,
		txVerificationPool:    executionPool,
		backlogQueue:          make(chan *txBacklogMsg, txBacklogSize),
		postVerificationQueue: make(chan *txBacklogMsg, txBacklogSize),
		net:                   net,
	}

	handler.ctx, handler.ctxCancel = context.WithCancel(context.Background())
	return handler
}

// Start enables the processing of incoming messages at the transaction handler
func (handler *TxHandler) Start() {
	handler.net.RegisterHandlers([]network.TaggedMessageHandler{
		{Tag: protocol.TxnTag, MessageHandler: network.HandlerFunc(handler.processIncomingTxn)},
	})
	handler.backlogWg.Add(1)
	go handler.backlogWorker()
}

// Stop suspends the processing of incoming messages at the transaction handler
func (handler *TxHandler) Stop() {
	handler.ctxCancel()
	handler.backlogWg.Wait()
}

func reencode(stxns []transactions.SignedTxn) []byte {
	var result [][]byte
	for _, stxn := range stxns {
		result = append(result, protocol.Encode(&stxn))
	}
	return bytes.Join(result, nil)
}

// backlogWorker is the worker go routine that process the incoming messages from the postVerificationQueue and backlogQueue channels and dispatches them further.
func (handler *TxHandler) backlogWorker() {
	defer handler.backlogWg.Done()
	for {
		// prioritize the postVerificationQueue
		select {
		case wi, ok := <-handler.postVerificationQueue:
			if !ok {
				return
			}
			handler.postprocessCheckedTxn(wi)

			// restart the loop so that we could empty out the post verification queue.
			continue
		default:
		}

		// we have no more post verification items. wait for either backlog queue item or post verification item.
		select {
		case wi, ok := <-handler.backlogQueue:
			if !ok {
				return
			}
			if handler.checkAlreadyCommitted(wi) {
				continue
			}

			// enqueue the task to the verification pool.
			handler.txVerificationPool.EnqueueBacklog(handler.ctx, handler.asyncVerifySignature, wi, nil)

		case wi, ok := <-handler.postVerificationQueue:
			if !ok {
				return
			}
			handler.postprocessCheckedTxn(wi)

		case <-handler.ctx.Done():
			return
		}
	}
}

func (handler *TxHandler) postprocessCheckedTxn(wi *txBacklogMsg) {
	if wi.verificationErr != nil {
		// disconnect from peer.
		logging.Base().Warnf("Received a malformed tx group %v: %v", wi.unverifiedTxGroup, wi.verificationErr)
		handler.net.Disconnect(wi.rawmsg.Sender)
		return
	}

	// we've processed this message, so increase the counter.
	transactionMessagesHandled.Inc(nil)

	// at this point, we've verified the transaction, so we can safely treat the transaction as a verified transaction.
	verifiedTxGroup := wi.unverifiedTxGroup

	// save the transaction, if it has high enough fee and not already in the cache
	err := handler.txPool.Remember(verifiedTxGroup)
	if err != nil {
		logging.Base().Debugf("could not remember tx: %v", err)
		return
	}

	// if we remembered without any error ( i.e. txpool wasn't full ), then we should pin these transactions.
	err = handler.ledger.VerifiedTransactionCache().Pin(verifiedTxGroup)
	if err != nil {
		logging.Base().Infof("unable to pin transaction: %v", err)
	}

	// We reencode here instead of using rawmsg.Data to avoid broadcasting non-canonical encodings
	handler.net.Relay(handler.ctx, protocol.TxnTag, reencode(verifiedTxGroup), false, wi.rawmsg.Sender)
}

// asyncVerifySignature verifies that the given transaction group is valid, and update the txBacklogMsg data structure accordingly.
func (handler *TxHandler) asyncVerifySignature(arg interface{}) interface{} {
	tx := arg.(*txBacklogMsg)

	// build the transaction verification context
	latest := handler.ledger.Latest()
	latestHdr, err := handler.ledger.BlockHdr(latest)
	if err != nil {
		tx.verificationErr = fmt.Errorf("Could not get header for previous block %d: %w", latest, err)
		logging.Base().Warnf("Could not get header for previous block %d: %v", latest, err)
	} else {
		// we can't use PaysetGroups here since it's using a execpool like this go-routine and we don't want to deadlock.
		_, tx.verificationErr = verify.TxnGroup(tx.unverifiedTxGroup, latestHdr, handler.ledger.VerifiedTransactionCache())
	}

	select {
	case handler.postVerificationQueue <- tx:
	default:
		// we failed to write to the output queue, since the queue was full.
		// adding the metric here allows us to monitor how frequently it happens.
		transactionMessagesDroppedFromPool.Inc(nil)
	}
	return nil
}

func (handler *TxHandler) processIncomingTxn(rawmsg network.IncomingMessage) network.OutgoingMessage {
	dec := protocol.NewDecoderBytes(rawmsg.Data)
	ntx := 0
	unverifiedTxGroup := make([]transactions.SignedTxn, 1)
	for {
		if len(unverifiedTxGroup) == ntx {
			n := make([]transactions.SignedTxn, len(unverifiedTxGroup)*2)
			copy(n, unverifiedTxGroup)
			unverifiedTxGroup = n
		}

		err := dec.Decode(&unverifiedTxGroup[ntx])
		if err == io.EOF {
			break
		}
		if err != nil {
			logging.Base().Warnf("Received a non-decodable txn: %v", err)
			return network.OutgoingMessage{Action: network.Disconnect}
		}
		ntx++
	}
	if ntx == 0 {
		logging.Base().Warnf("Received empty tx group")
		return network.OutgoingMessage{Action: network.Disconnect}
	}
	unverifiedTxGroup = unverifiedTxGroup[:ntx]

	select {
	case handler.backlogQueue <- &txBacklogMsg{
		rawmsg:            &rawmsg,
		unverifiedTxGroup: unverifiedTxGroup,
	}:
	default:
		// if we failed here we want to increase the corresponding metric. It might suggest that we
		// want to increase the queue size.
		transactionMessagesDroppedFromBacklog.Inc(nil)
	}

	return network.OutgoingMessage{Action: network.Ignore}
}

// checkAlreadyCommitted test to see if the given transaction ( in the txBacklogMsg ) was already committed, and
// whether it would qualify as a candidate for the transaction pool.
//
// Note that this also checks the consistency of the transaction's group hash,
// which is required for safe transaction signature caching behavior.
/*
	주어진 트랜잭션( txBacklogMsg 에 있음)이 이미 커밋되었는지(트랜잭션 풀에 들어가있는지) 확인하기 위한 checkAlreadyCommitted 테스트 및
	트랜잭션 풀의 후보로 적합한지 여부. 이것은 또한 안전한 트랜잭션 서명 캐싱 동작에 필요한 트랜잭션 그룹 해시의 일관성을 확인합니다.
*/
func (handler *TxHandler) checkAlreadyCommitted(tx *txBacklogMsg) (processingDone bool) {
	txids := make([]transactions.Txid, len(tx.unverifiedTxGroup))
	for i := range tx.unverifiedTxGroup {
		txids[i] = tx.unverifiedTxGroup[i].ID()
	}
	logging.Base().Debugf("got a tx group with IDs %v", txids)

	// do a quick test to check that this transaction could potentially be committed, to reject dup pending transactions
	err := handler.txPool.Test(tx.unverifiedTxGroup)
	if err != nil {
		logging.Base().Debugf("txPool rejected transaction: %v", err)
		return true
	}
	return false
}

func (handler *TxHandler) processDecoded(unverifiedTxGroup []transactions.SignedTxn) (outmsg network.OutgoingMessage, processingDone bool) {
	tx := &txBacklogMsg{
		unverifiedTxGroup: unverifiedTxGroup,
	}

	// 해당 트랜잭션 그룹이 이미 트랜잭션 풀에 들어가 있는지 확인
	if handler.checkAlreadyCommitted(tx) {
		return network.OutgoingMessage{}, true
	}

	// build the transaction verification context
	// 직전 블록의 헤더 정보 가져오기
	latest := handler.ledger.Latest()
	latestHdr, err := handler.ledger.BlockHdr(latest)
	if err != nil {
		logging.Base().Warnf("Could not get header for previous block %v: %v", latest, err)
		return network.OutgoingMessage{}, true
	}

	// 트랜잭션 검증
	unverifiedTxnGroups := bookkeeping.SignedTxnsToGroups(unverifiedTxGroup)

	// 트랜잭션그룹을 검증하고 검증이 완료되면 검증된 캐시의 bucket부분에 트랜잭션 그룹을 넣어준다.
	err = verify.PaysetGroups(context.Background(), unverifiedTxnGroups, latestHdr, handler.txVerificationPool, handler.ledger.VerifiedTransactionCache())
	if err != nil {
		// transaction is invalid
		logging.Base().Warnf("One or more transactions were malformed: %v", err)
		return network.OutgoingMessage{Action: network.Disconnect}, true
	}

	// at this point, we've verified the transaction group,
	// so we can safely treat the transaction as a verified transaction.
	// 위에서 검증 완료했으므로 verifiedTxGroup에 넣어줌
	verifiedTxGroup := unverifiedTxGroup

	// save the transaction, if it has high enough fee and not already in the cache
	// 충분한 수수료를 가지고 있고 캐시에 들어가 있지 않다면 트랜잭션풀에 저장한다.
	err = handler.txPool.Remember(verifiedTxGroup)
	if err != nil {
		logging.Base().Debugf("could not remember tx: %v", err)
		return network.OutgoingMessage{}, true
	}

	// if we remembered without any error ( i.e. txpool wasn't full ), then we should pin these transactions.
	// 풀의 remember에 잘 저장했다면(풀이 넘치는 에러가 없다면) 해당 트랜잭션을 캐시의 pin영역으로 이동시킨다.
	err = handler.ledger.VerifiedTransactionCache().Pin(verifiedTxGroup)
	if err != nil {
		logging.Base().Warnf("unable to pin transaction: %v", err)
	}

	// 검증완료 되어 캐시에 들어갔고 고정까지 완료 됐다면 false 리턴!
	return network.OutgoingMessage{}, false
}

// SolicitedTxHandler handles messages received through channels other than the gossip network.
// It therefore circumvents the notion of incoming/outgoing messages
/*
SolicitedTxHandler는 가십 네트워크 이외의 채널을 통해 수신된 메시지를 처리합니다.
따라서 수신/발신 메시지의 개념을 우회합니다.
*/
type SolicitedTxHandler interface {
	Handle(txgroup []transactions.SignedTxn) error
}

// SolicitedTxHandler converts a transaction handler to a SolicitedTxHandler
func (handler *TxHandler) SolicitedTxHandler() SolicitedTxHandler {
	return &solicitedTxHandler{txHandler: handler}
}

type solicitedTxHandler struct {
	txHandler *TxHandler
}

func (handler *solicitedTxHandler) Handle(txgroup []transactions.SignedTxn) error {
	outmsg, _ := handler.txHandler.processDecoded(txgroup)
	if outmsg.Action == network.Disconnect {
		return fmt.Errorf("invalid transaction")
	}
	return nil
}
